#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <sys/random.h>
#include <sys/stat.h>
#include <string.h>
#include <err.h>
#include <sodium.h>
#include <stdnoreturn.h>
#include <stdarg.h>
#include <fcntl.h>


#include <getopt.h>
#include "readsecret.h"

enum action_t {
  ENCRYPT = 1,
  DECRYPT,
  KEYGEN,
  PUBKEY,
};

struct args {
  enum action_t action;
  const char *file;
};

struct args_encrypt {
  const char *keyfile;
  const char *secretfile;
  const char *outfile
};


#define ACTION(args, a) if ((args)->action != 0) return -1; else (args)->action = (a)
#define MAX(a, b) ((a) >= (b) ? (a) : (b))
extern char *readpassphrase(const char *prompt, char *buf, size_t bufsiz);

int foo(int argc, char **argv, struct args *args) {
  opterr = 0;
  struct option options[] = {
    {
      .name = "encrypt",
      .has_arg = no_argument,
      .flag = NULL,
      .val = 'e'
    },
    {
      .name = "decrypt",
      .has_arg = no_argument,
      .flag = NULL,
      .val = 'd'
    },
    {
      .name = "keygen",
      .has_arg = no_argument,
      .flag = NULL,
      .val = 'k'
    },
    {
      .name = "pubkey",
      .has_arg = no_argument,
      .flag = NULL,
      .val = 'p'
    },
    {
      .name = "file",
      .has_arg = required_argument,
      .flag = NULL,
      .val = 'f'
    },
    {0}
  };
  
  int opt;
  args->action = 0;
  args->file = NULL;
  while ((opt = getopt_long(argc, argv, "def:", options, NULL)) != -1) {
    switch (opt) {
    case 'd':
      ACTION(args, DECRYPT);
      /*
      if (args->action != 0) {
        return -1;
      } else {
        args->action = DECRYPT;
      }
      */
      break;
    case 'e':
      encrypt
      if (args->action != 0) {
        return -1;
      } else {
        args->action = ENCRYPT;
      }
      break;
    case 'f':
      args->file = optarg;
      break;
    default:
      return -1;
    }
    if (args->action == 0) {
      return -1;
    }
    printf("opt = %c, optarg = %s\n", opt, optarg);
  }
  return 0;
}

void usage(const char *arg0) {
  printf("Usage: %s [options]\n", arg0);
  puts("Options:");
  puts(" -e, --encrypt       encrypt");
  puts(" -d, --decrypt       scan input for encrypted content, i.e. ENC[...], decrypt it, and write to stdout");
  puts(" -f, --file=FILE     read from FILE instead of stdin");
  puts(" -k, --keygen        generate new key pair");
  puts(" -p, --pubkey        read private key from terminal/file and print public key to stdout");
}


#define LSX(rv, func) if ((rv) != 0) errx(EXIT_FAILURE, #func " failed")

// #define LS(func, ...) do { int r = func(__VA_ARGS__); if} while(0)
#define LS(func, ...) LSX(func(__VA_ARGS__), func)


noreturn void create_keypair() {
  unsigned char pk[crypto_box_PUBLICKEYBYTES];
  unsigned char sk[crypto_box_SECRETKEYBYTES];
  char buf[MAX(crypto_box_PUBLICKEYBYTES, crypto_box_SECRETKEYBYTES) * 2 + 1];
  LS(crypto_box_keypair, pk, sk);
  printf("private: %s\n", sodium_bin2hex(buf, sizeof(buf), sk, crypto_box_SECRETKEYBYTES));
  printf("public:  %s\n", sodium_bin2hex(buf, sizeof(buf), pk, crypto_box_PUBLICKEYBYTES));
  sodium_memzero(sk, crypto_box_SECRETKEYBYTES);
  exit(EXIT_SUCCESS);
}

noreturn void
compute_publickey(const char *sk_hex) {
  unsigned char sk[crypto_box_SECRETKEYBYTES];
  unsigned char buf[MAX(crypto_box_SECRETKEYBYTES, crypto_box_PUBLICKEYBYTES) * 2 + 1];
  unsigned char pk[crypto_box_PUBLICKEYBYTES];
  const char *s;
  size_t n;
  int r;

  if (readpassphrase("private key: ", buf, sizeof(buf)) == NULL) {
    errx(EXIT_FAILURE, "Cannot read private key");
  }

  // char buf[crypto_box_PUBLICKEYBYTES * 2 + 1], *s;
  n = strlen(buf);
  if (n != crypto_box_SECRETKEYBYTES * 2) {
    sodium_memzero(buf, sizeof(buf));
    errx(EXIT_FAILURE, "Invalid secret key");
  }
  if (sodium_hex2bin(sk, crypto_box_SECRETKEYBYTES, buf, n, NULL, &n, &s) != 0
      || n != crypto_box_SECRETKEYBYTES 
      || *s != '\0') {
    errx(EXIT_FAILURE, "Invalid secret key");
  }
  r = crypto_scalarmult_base(pk, sk);
  sodium_memzero(sk, crypto_box_SECRETKEYBYTES);
  sodium_memzero(buf, sizeof(buf));
  LSX(r, crypto_scalarmult_base);
  printf("public:  %s\n", sodium_bin2hex(buf, sizeof(buf), pk, crypto_box_PUBLICKEYBYTES));
  exit(EXIT_SUCCESS);
}

static int readhexkey(const char *path, unsigned char key[32]) {
  char buf[128], *p;
  size_t bufsz = sizeof(buf);
  FILE *f;
  int rv = -1;
  int fd, n;

  if ((fd = open(path, O_RDONLY)) == -1) {
    return -1;
  }

  while (bufsz && (n = read(fd, p, bufsz)) > 0) {
    bufsz -= n;
    p += n;
  }
  close(fd);
  if (n == -1) {
    err(EXIT_FAILURE, "cannot read public key from `%s'", path);
  }
  if (n > 0) {
    errx(EXIT_FAILURE, "invalid public key");
  }
  bufsz = sizeof(buf) - bufsz;
  n = 0;     
  if (sodium_hex2bin(key, 32, buf, bufsz, ": \t\r\n", &bufsz, NULL) == -1 || n != 32) {
    errx(EXIT_FAILURE, "invalid public key");
  }
}

int readsecret(const char *path, char *buf, size_t bufsz) {
  size_t n, r;
  char *p = buf;
  int fd;

  if ((fd = open(path, O_RDONLY)) == -1) {
    return -1;
  }
  while ((r = read(fd, p, bufsz)) > 0) {
    bufsz -= r;
    p += r;
  }
  close(fd);
  if (r == -1 || bufsz > 0) {
    return -1;
  }
  return 0;
}


noreturn void
encrypt(const struct args_encrypt *args) {
  int rsflags = 0;
  char hexkey[64];
  if (args->keyfile && readhexkey(args->keyfile, hexkey) == -1) {
    err(EXIT_FAILURE, "cannot read key from %s", args->keyfile);
  }
}

#define TEST
#ifdef TEST







#endif
